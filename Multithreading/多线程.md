## 专业名词

- 竞态条件：多线程的核心矛盾是”竞态条件“，即多个线程同时读写某个字段

- 竞态资源：竞态条件下多线程争抢的是“竞态资源”

- 临界区：涉及读写静态资源的**代码片段**叫“临界区”

- 互斥：保证竞态资源安全的最朴素的一个思路就是让临界区代码“互斥”，即同一时刻最多只能有一个线程进入临界区

  最朴素的互斥手段：在进入临界区之前，用if检查一个bool值，条件不满足就“忙等”，这叫“锁变量”。但锁变量不是线程安全的，因为“检查-占锁”这个动作不具备“原子性”

- TSL：“TSL指令”就是原子性的完成“检查-占锁”的动作

- 自旋锁：当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断锁是否能够被成功获取，直到获取到锁才会退出循环

- 忙等待：自旋锁的缺点是条件不满足时会“忙等待”，需要后台调度器重新分配时间片，效率低

  解决忙等待的是：“sleep”和“wakeup“两个原语。sleep阻塞当前线程的同时不会让出它占用的锁。wakeup可以唤醒在目标锁上睡眠的线程

- 互斥量：使用sleep和wakeup原语，保证同一时间只有一个线程进入临界区代码片段的锁叫”互斥量“

- 信号量：把互斥锁推广到”N“的空间，同时允许有N个线程进入临界区的锁叫”信号量“。互斥量和信号量的实现都以来TSL指令保证”检查-占锁“的原子性

- 原子性操作：一个或某几个操作只能在一个线程执行完之后，另一个线程才能开始执行操作，也就是说这些操作时不可分割的，线程不能在这些操作上交替执行

  例如：i++不是原子性操作，它相当于三个原子性操作：

  1. 读取变量i的值；
  2. 将变量i的值加1；
  3. 将结果写入变量i中；

  

