## 容器

容器就是一些**特定类型对象的集合**



### 顺序容器

为程序员提供了控制元素存储和访问顺序的能力,这种顺序不依赖于元素的值,而是与元素加入容器时的位置相对应

顺序容器类型有:

- vector       可变大小数组,支持快速随机访问,在尾部之外的位置插入或删除元素可能很慢
- deque       双端队列,支持快速随机访问,在头尾位置插入/删除速度很快
- list              双向链表,只支持双向顺序访问,在list中任何位置插入删除都很快
- forward_list  单向链表,只支持单向顺序访问,在链表中任何位置插入删除都很快
- array           固定大小数组,支持快速随机访问,不能添加或删除元素
- string           与vector相似的容器,专门用于保存字符,支持快速随机访问,在尾部位置插入/删除速度很快

通常使用vector是最好的选择,顺序容器几乎可以保存任意类型的元素,可以定义一个容器,其元素类型是另一个容器,有**些较旧的编译器可能需要在两个尖括号间键入空格**

> vector<vector<string> > line



#### 容器操作

- 构造函数

  > C  c;                       默认构造函数,构造空容器
  >
  > C  c1(c2);               构造c2的拷贝c1
  >
  > C  c(b, e);                构造c,将**迭代器b和e所指定的范围内**的元素拷贝到c
  >
  > C   c{a, b, c...};        列表初始化c

- 赋值和swap

  > c1 = c2;
  >
  > c1 = {a, b, c...}; 
  >
  > a.swap(b);      交换a和b的元素
  >
  > swap(a, b);      与a.swap(b)等价

- 大小

  > c.size();                     c中元素数目
  >
  > c.max_size();           c可保存的最大元素数目
  >
  > c.empty();                c为空容器则返回true,不为空则返回false
  >
  > c.resize(n);               调整c的大小为n个元素,若n<c.size(),则多出去的元素被丢弃,否则对新元素进行默认初始化

- 添加删除元素

  > c.insert(args);       将args中的元素拷贝进c
  >
  > c.emplace(inits);   使用inits构造c中的一个元素
  >
  > c.erase(args);         删除args指定的元素
  >
  > c.clear();                   清空c中所有元素
  >
  > ​	
  >
  > 在新标准下,insert函数返回指向第一个新加入元素的迭代器

- 关系运算符

  > - 两个容器大小且对应元素都相同,则这两个容器相等,否则不等
  > - 大小不同但较小容器中每个元素都等于较大容器中的对应元素,则较小容器小于较大容器
  > - 如果两个容器都是不是对方的前缀子序列,那么**结果取决于第一个不相等的元素的比较结果**

  



### 迭代器

要访问顺序容器和关联容器中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。与指针类似,通过解引用获取它所指示的元素。和指针不一样的是,获取迭代器不是使用取地址符,有迭代器的类型同时拥有返回迭代器的成员,比如这些类型都拥有begin和end的成员,其中begin成员负责指向第一个元素的迭代器

- 用迭代器遍历容器

  > for(auto it = s.begin(); it!= s.end(); it++)



所有标准库容器都可以使用迭代器,但是其中只有少数几种同时支持下标运算,

- 用法:通过迭代器可以读取它指向的元素，`*迭代器名`就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。

  迭代器都可以进行`++`操作。反向迭代器和正向迭代器的区别在于：

  - 对正向迭代器进行`++`操作时，迭代器会指向容器中的后一个元素；
  - 而对反向迭代器进行`++`操作时，迭代器会指向容器中的前一个元素。

